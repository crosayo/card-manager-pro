
'use client';

import React, { useState, useEffect, useRef } from 'react';
import { Settings, Shield, Loader2, Save, FileUp, Database, AlertCircle, CheckCircle2, List, Copy, Terminal, Download, Trash2, AlertTriangle, RefreshCw, Calendar, Plus, Wand2, Upload } from 'lucide-react';
import { api } from '../services/api';
import { AppError, Season, ToastType } from '../types';
import { useAppContext } from '../context/AppContext';

interface SettingsViewProps {
  isAdmin: boolean;
  isLoading: boolean;
  addToast: (type: ToastType['type'], title: string, message?: string, errorDetail?: AppError) => void;
}

// ユーザー指定のSQL
const INITIAL_SCHEMA_SQL = `-- 1. お知らせテーブルの作成
create table if not exists public.news (
  id bigint generated by default as identity primary key,
  content text not null,
  type text not null, -- 'info' | 'alert' | 'success'
  start_date date default current_date,
  end_date date, -- null = permanent
  created_at timestamptz default now()
);

-- 2. アイテムテーブル (発売日カラムなし)
create table if not exists public.items (
  id bigint generated by default as identity primary key,
  name text not null,
  card_id text,
  rarity text,
  stock integer default 0,
  category text,
  updated_at timestamptz default now()
);

-- 3. 製品テーブル
create table if not exists public.products (
  name text not null primary key,
  release_date text,
  is_sidebar_visible boolean default true,
  created_at timestamptz default now()
);

-- もしカラムが足りない場合（エラー対策）
alter table public.products add column if not exists created_at timestamptz default now();

create table if not exists public.config (
  key text not null primary key,
  value jsonb
);

-- 4. RLS (セキュリティ設定)
alter table public.news enable row level security;
alter table public.items enable row level security;
alter table public.products enable row level security;
alter table public.config enable row level security;

-- ポリシーの設定
drop policy if exists "Allow public read access" on public.news;
create policy "Allow public read access" on public.news for select using (true);
drop policy if exists "Allow authenticated all" on public.news;
create policy "Allow authenticated all" on public.news for all using (auth.role() = 'authenticated');

drop policy if exists "Allow public read access" on public.items;
create policy "Allow public read access" on public.items for select using (true);
drop policy if exists "Allow authenticated insert" on public.items;
create policy "Allow authenticated insert" on public.items for insert with check (auth.role() = 'authenticated');
drop policy if exists "Allow authenticated update" on public.items;
create policy "Allow authenticated update" on public.items for update using (auth.role() = 'authenticated');
drop policy if exists "Allow authenticated delete" on public.items;
create policy "Allow authenticated delete" on public.items for delete using (auth.role() = 'authenticated');

drop policy if exists "Allow public read access" on public.products;
create policy "Allow public read access" on public.products for select using (true);
drop policy if exists "Allow authenticated insert" on public.products;
create policy "Allow authenticated insert" on public.products for insert with check (auth.role() = 'authenticated');
drop policy if exists "Allow authenticated update" on public.products;
create policy "Allow authenticated update" on public.products for update using (auth.role() = 'authenticated');
drop policy if exists "Allow authenticated delete" on public.products;
create policy "Allow authenticated delete" on public.products for delete using (auth.role() = 'authenticated');

drop policy if exists "Allow public read access" on public.config;
create policy "Allow public read access" on public.config for select using (true);
drop policy if exists "Allow authenticated all" on public.config;
create policy "Allow authenticated all" on public.config for all using (auth.role() = 'authenticated');

-- 5. 自動更新トリガー
create or replace function public.handle_updated_at() 
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

drop trigger if exists on_items_updated on public.items;
create trigger on_items_updated
  before update on public.items
  for each row execute procedure public.handle_updated_at();

-- 6. RPC関数 (ダッシュボード統計)
create or replace function public.get_dashboard_stats()
returns json
language plpgsql
security definer
as $$
declare
  total_cards integer;
  total_stock integer;
  low_stock integer;
begin
  select count(*) into total_cards from public.items;
  select coalesce(sum(stock), 0) into total_stock from public.items;
  select count(*) into low_stock from public.items where stock < 2;
  return json_build_object('totalCards', total_cards, 'totalStock', total_stock, 'lowStock', low_stock);
end;
$$;

-- 7. RPC関数 (データリセット)
create or replace function public.reset_all_data()
returns void
language plpgsql
security definer
as $$
begin
  truncate table public.items restart identity cascade;
  truncate table public.products cascade;
  truncate table public.news restart identity cascade;
end;
$$;

-- 8. RPC関数 (レアリティ集計)
create or replace function public.get_distinct_rarities()
returns table (rarity text)
language plpgsql
security definer
as $$
begin
  return query select distinct i.rarity from public.items i order by i.rarity;
end;
$$;
`;

export const SettingsView: React.FC<SettingsViewProps> = ({ 
  isAdmin, 
  isLoading: globalLoading, 
  addToast 
}) => {
  const { rarities, refreshRarities, seasons, refreshSeasons, refreshProducts } = useAppContext();
  const [newRarity, setNewRarity] = useState("");
  const [localRarities, setLocalRarities] = useState<string[]>([]);
  
  const [localSeasons, setLocalSeasons] = useState<Season[]>([]);
  const [newSeasonData, setNewSeasonData] = useState({ name: '', startDate: '' });

  const [isSaving, setIsSaving] = useState(false);
  const [isResetting, setIsResetting] = useState(false);
  
  const [isBackingUp, setIsBackingUp] = useState(false);
  const [backupProgress, setBackupProgress] = useState(0);

  const [isRestoring, setIsRestoring] = useState(false);
  const importFileRef = useRef<HTMLInputElement>(null);

  // Normalization state
  const [isNormalizing, setIsNormalizing] = useState(false);
  const [normalizationCount, setNormalizationCount] = useState(0);

  useEffect(() => {
    setLocalRarities(rarities);
    setLocalSeasons(seasons);
  }, [rarities, seasons]);

  const copyToClipboard = (text: string, title: string) => {
    navigator.clipboard.writeText(text);
    addToast('success', 'コピーしました', `${title}をクリップボードにコピーしました。`);
  };

  const saveConfig = async () => {
    setIsSaving(true);
    try {
      await api.saveRarities(localRarities);
      await api.saveSeasons(localSeasons);
      await refreshRarities();
      await refreshSeasons();
      addToast('success', '設定保存完了', 'システム設定をデータベースに保存しました。');
    } catch (e: any) {
      addToast('error', '設定の保存に失敗しました', e.message);
    } finally {
      setIsSaving(false);
    }
  };

  const addSeason = () => {
    if (!newSeasonData.name || !newSeasonData.startDate) {
      addToast('error', '入力エラー', 'シーズン名と開始日を入力してください');
      return;
    }
    const newSeason: Season = {
      id: crypto.randomUUID ? crypto.randomUUID() : Date.now().toString(),
      name: newSeasonData.name,
      startDate: newSeasonData.startDate
    };
    const updated = [...localSeasons, newSeason].sort((a, b) => 
      new Date(b.startDate).getTime() - new Date(a.startDate).getTime()
    );
    setLocalSeasons(updated);
    setNewSeasonData({ name: '', startDate: '' });
  };

  const handleBackup = async () => {
    setIsBackingUp(true);
    setBackupProgress(0);
    try {
      const products = await api.fetchProducts();
      const items = await api.fetchAllItemsForBackup((count) => {
        setBackupProgress(count);
      });
      const backupData = {
        products,
        items,
        exportDate: new Date().toISOString(),
        version: "4.5"
      };
      const blob = new Blob([JSON.stringify(backupData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `backup_${new Date().toISOString().split('T')[0]}.json`;
      link.click();
      URL.revokeObjectURL(url);
      addToast('success', 'バックアップ完了', `${items.length}件のデータをエクスポートしました。`);
    } catch (e: any) {
      addToast('error', 'バックアップ失敗', e.message);
    } finally {
      setIsBackingUp(false);
      setBackupProgress(0);
    }
  };

  const handleImportBackup = () => {
    importFileRef.current?.click();
  };

  const handleFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    if (!window.confirm(`「${file.name}」を復元しますか？\n既存のデータのうち、IDや製品名が一致するものは上書きされます。`)) {
      e.target.value = '';
      return;
    }

    setIsRestoring(true);
    const reader = new FileReader();
    reader.onload = async (event) => {
      try {
        const text = event.target?.result as string;
        const backupData = JSON.parse(text);

        if (!backupData.products && !backupData.items) {
          throw new Error('無効なバックアップファイル形式です');
        }

        await api.restoreFromBackup(backupData);
        await refreshProducts();
        addToast('success', '復元完了', 'バックアップからのデータ復元が完了しました。');
      } catch (err: any) {
        addToast('error', '復元失敗', err.message);
      } finally {
        setIsRestoring(false);
        if (importFileRef.current) importFileRef.current.value = '';
      }
    };
    reader.readAsText(file);
  };

  const handleNormalization = async () => {
    if (!window.confirm("全データの表記揺れ修正と記号(《》)削除を実行しますか？\n\n・全角英数 → 半角英数\n・半角カナ → 全角カナ\n・《》の削除\n\nこの処理はデータベース内の全アイテムを更新するため時間がかかる場合があります。")) {
      return;
    }
    setIsNormalizing(true);
    setNormalizationCount(0);
    try {
      const count = await api.normalizeAllItems((progress) => setNormalizationCount(progress));
      addToast('success', '正規化完了', `${count}件のデータの表記揺れを修正しました。`);
    } catch (e: any) {
      addToast('error', '正規化失敗', e.message);
    } finally {
      setIsNormalizing(false);
      setNormalizationCount(0);
    }
  };

  const handleResetData = async () => {
    if (!window.confirm("【警告】本当にすべてのデータを削除しますか？\n\nこの操作は元に戻せません。")) {
      return;
    }
    setIsResetting(true);
    try {
      await api.resetDatabase();
      await refreshProducts();
      addToast('success', 'データ削除完了', 'データベースを初期化しました。');
    } catch (e: any) {
      addToast('error', '削除失敗', e.message);
    } finally {
      setIsResetting(false);
    }
  };

  return (
    <div className="p-4 md:p-8 max-w-4xl mx-auto pb-24">
      <h2 className="text-2xl font-bold text-slate-800 mb-6 flex items-center gap-2">
        <Settings /> システム設定
      </h2>
      
      {!isAdmin ? (
        <div className="bg-red-50 p-6 rounded-lg text-red-600 border border-red-200 flex items-center gap-3">
           <Shield size={24} />
           <div className="font-bold">このページにアクセスする権限がありません</div>
        </div>
      ) : (
        <div className="space-y-8">
          {/* SQL Editor Section */}
          <div className="bg-amber-50 border-l-4 border-amber-500 p-6 rounded-lg shadow-sm">
            <h3 className="text-lg font-bold text-amber-800 flex items-center gap-2 mb-2">
              <AlertCircle /> データベース構成 (SQL)
            </h3>
            <p className="text-amber-700 mb-4 text-sm">
              お知らせ機能対応・発売日順ソート対応のためのテーブル定義です。<br/>
              Supabaseの <b>SQL Editor</b> でこのスクリプトを実行してください。
            </p>
            <div className="relative bg-slate-900 rounded-lg p-4 mb-4 font-mono text-xs text-slate-300 h-64 overflow-y-auto custom-scrollbar border border-slate-700">
              <pre>{INITIAL_SCHEMA_SQL}</pre>
              <button 
                onClick={() => copyToClipboard(INITIAL_SCHEMA_SQL, "SQLスクリプト")}
                className="absolute top-2 right-2 bg-white/10 hover:bg-white/20 text-white p-2 rounded transition-colors"
                title="SQLをコピー"
              >
                <Copy size={16} />
              </button>
            </div>
            <div className="flex justify-end">
              <a 
                href="https://supabase.com/dashboard" 
                target="_blank" 
                rel="noopener noreferrer"
                className="bg-amber-600 text-white px-4 py-2 rounded-lg font-bold hover:bg-amber-700 flex items-center gap-2 text-sm"
              >
                <Terminal size={16} /> Supabase SQL Editorを開く
              </a>
            </div>
          </div>

          {/* Data Maintenance */}
          <div className="bg-white p-6 rounded-xl shadow-sm border border-slate-200">
            <h3 className="text-lg font-bold text-slate-700 mb-4 border-b pb-2 flex items-center gap-2">
              <Wand2 className="text-purple-600" /> データメンテナンス
            </h3>
            <div className="flex items-center justify-between">
              <div>
                <p className="font-bold text-slate-700 mb-1">データの正規化と記号削除</p>
                <p className="text-xs text-slate-500">全アイテムの「半角/全角統一」と「《》」の削除を一括で行います。<br/>検索ヒット率の向上に役立ちます。</p>
              </div>
              <button
                onClick={handleNormalization}
                disabled={isNormalizing || globalLoading}
                className="bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded-lg font-bold flex items-center gap-2 disabled:opacity-50 text-sm"
              >
                {isNormalizing ? <Loader2 className="animate-spin" size={16} /> : <RefreshCw size={16} />}
                {isNormalizing ? `処理中... ${normalizationCount}件` : '正規化を実行'}
              </button>
            </div>
          </div>

          {/* Backup & Restore */}
          <div className="bg-white p-6 rounded-xl shadow-sm border border-slate-200">
            <h3 className="text-lg font-bold text-slate-700 mb-4 border-b pb-2 flex items-center gap-2">
              <Database className="text-blue-600" /> バックアップと復元
            </h3>
            <div className="flex flex-col sm:flex-row gap-4">
              <button
                onClick={handleBackup}
                disabled={isBackingUp || globalLoading}
                className="flex-1 bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-lg font-bold flex items-center justify-center gap-2 disabled:opacity-50"
              >
                {isBackingUp ? <Loader2 className="animate-spin" size={18} /> : <Download size={18} />}
                {isBackingUp ? `取得中... ${backupProgress}件` : 'バックアップ (Export)'}
              </button>

              <button
                onClick={handleImportBackup}
                disabled={isRestoring || globalLoading}
                className="flex-1 bg-emerald-600 hover:bg-emerald-700 text-white px-6 py-3 rounded-lg font-bold flex items-center justify-center gap-2 disabled:opacity-50"
              >
                {isRestoring ? <Loader2 className="animate-spin" size={18} /> : <Upload size={18} />}
                {isRestoring ? '復元中...' : 'バックアップを復元 (Import)'}
              </button>
              <input 
                type="file" 
                ref={importFileRef}
                onChange={handleFileChange}
                accept=".json"
                className="hidden"
              />
            </div>
            <p className="text-xs text-slate-400 mt-2">
              ※ バックアップファイル(.json)を読み込んでデータベースを復元します。IDが重複するデータは上書きされます。
            </p>
          </div>

          {/* Seasons */}
          <div className="bg-white p-6 rounded-xl shadow-sm border border-slate-200">
            <h3 className="text-lg font-bold text-slate-700 mb-4 border-b pb-2 flex items-center gap-2">
              <Calendar className="text-green-600" /> シーズン定義
            </h3>
            <div className="flex flex-col md:flex-row gap-4 mb-4 items-end bg-slate-50 p-4 rounded-lg">
              <input 
                type="text" 
                value={newSeasonData.name}
                onChange={(e) => setNewSeasonData({ ...newSeasonData, name: e.target.value })}
                placeholder="例: 第13期 (2025~)"
                className="flex-1 border border-slate-300 rounded px-3 py-2 text-sm"
              />
              <input 
                type="date" 
                value={newSeasonData.startDate}
                onChange={(e) => setNewSeasonData({ ...newSeasonData, startDate: e.target.value })}
                className="w-full md:w-40 border border-slate-300 rounded px-3 py-2 text-sm"
              />
              <button onClick={addSeason} className="bg-green-600 text-white px-4 py-2 rounded font-bold hover:bg-green-700 flex items-center gap-2 shrink-0">
                <Plus size={16} /> 追加
              </button>
            </div>
            <div className="flex justify-end mt-4">
              <button onClick={saveConfig} disabled={isSaving || globalLoading} className="bg-cyan-600 text-white px-8 py-2 rounded-lg font-bold hover:bg-cyan-700 flex items-center gap-2">
                {isSaving ? <Loader2 className="animate-spin" size={18} /> : <Save size={18} />}
                設定を保存
              </button>
            </div>
          </div>

          {/* Danger Zone */}
          <div className="border border-red-200 rounded-xl overflow-hidden">
             <div className="bg-red-50 p-4 border-b border-red-200 flex items-center gap-2 text-red-700 font-bold">
               <AlertTriangle size={20} /> Danger Zone (全データの削除)
             </div>
             <div className="p-6 bg-white">
               <button
                 onClick={handleResetData}
                 disabled={isResetting || globalLoading}
                 className="bg-red-600 hover:bg-red-700 text-white px-6 py-3 rounded-lg font-bold shadow-md disabled:opacity-50 flex items-center gap-2 transition-colors ml-auto"
               >
                 {isResetting ? <Loader2 className="animate-spin" size={18} /> : <Trash2 size={18} />}
                 データベースを完全にリセットする
               </button>
             </div>
          </div>
        </div>
      )}
    </div>
  );
};
